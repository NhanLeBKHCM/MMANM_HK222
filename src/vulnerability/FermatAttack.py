# Some code derived from https://github.com/google/paranoid_crypto/
import gmpy2
from gmpy2 import mpz, xmpz
import random
import sys

class RSAKey:
    def __init__(self): # constructor method
      e=bytearray(0)
      n=bytearray(0)  

def Int2Bytes(int_val: int):
    return int.to_bytes(int(int_val), (int_val.bit_length() + 7) // 8, 'big')

def Bytes2Int(bytes_val: bytes) -> int:
    return int.from_bytes(bytes_val, 'big')

def FermatFactor(n: int, max_steps: int):
    if n % 2 == 0:
        return 2, n // 2
    a = gmpy2.isqrt(n)
    if a * a == n:
        return a, a
    a += 1  # ceil(sqrt(n))
    b2 = a * a - n
    for _ in range(max_steps):
        if gmpy2.is_square(b2):
            return a + gmpy2.isqrt(b2), a - gmpy2.isqrt(b2)
        b2 += a
        a += 1
        b2 += a
    return None


nsize=1024
rsa_key1=RSAKey()
max_steps = 3


if (len(sys.argv)>1):
	nsize=int(sys.argv[1])

print(f"Prime number size: {nsize} bits\n")
print(f"N size: {nsize*2} bits\n")
p = gmpy2.next_prime(random.getrandbits(nsize))
q = gmpy2.next_prime(p + 2**(nsize*1//2))

rsa_key1.n=p * q
print(f"== Try with p and q close to each other (within {2}^{nsize*1//2}=N^1/4)==\n")
print(f"N={rsa_key1.n}")

result = FermatFactor(rsa_key1.n, max_steps)

try:
    if ((result[0] * result[1])==rsa_key1.n):
        print(f"Able to factor: \n  p={result[0]}\n  q={result[1]}")
except:
    print("Success: Not able to factor")


p = gmpy2.next_prime(random.getrandbits(nsize))
q = gmpy2.next_prime(p + 2**(nsize*4//7))

rsa_key1.n=p * q 
print(f"\n== Try with p and q as random primes (within {2}^{nsize*4//7}=N^2/7)==\n")
print(f"N={rsa_key1.n}")
result = FermatFactor(rsa_key1.n, max_steps)
try:
    if ((result[0] * result[1])==rsa_key1.n):
        print(f"Able to factor: \n  p={result[0]}\n  q={result[1]}")
except:
    print("Success: Not able to factor")